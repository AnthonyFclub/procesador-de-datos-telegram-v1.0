# -*- coding: utf-8 -*-
"""Copia de procesador-datos-telegram-v1.0

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VDjhCPJT5VM7w9mMtxWjJpsxDKmiGgph
"""

import json
import pandas as pd
import re
from datetime import datetime

class TelegramDataProcessor:
    """
    Procesador avanzado para archivos JSON de Telegram.
    Extrae y analiza datos de usuarios para identificar Builders potenciales.
    """

    def __init__(self, json_path):
        """Inicializa el procesador con la ruta al archivo JSON"""
        self.json_path = json_path
        self.data = None
        self.users = {}
        self.user_messages = {}
        self.message_counts = {}

        # Diccionarios para identificar roles y habilidades
        self.role_keywords = {
            'Developer': ['desarrollador', 'programador', 'coder', 'engineer', 'ingeniero', 'dev', 'fullstack', 'frontend', 'backend'],
            'Designer': ['diseñador', 'designer', 'ux', 'ui', 'interfaz', 'figma', 'sketch'],
            'Product Manager': ['product manager', 'pm', 'product owner', 'gerente de producto', 'scrum'],
            'Marketing': ['marketing', 'growth', 'community manager', 'social media'],
            'Founder': ['founder', 'fundador', 'ceo', 'co-founder', 'emprendedor', 'startup']
        }

        self.tech_keywords = {
            'Frontend': ['react', 'vue', 'angular', 'javascript', 'typescript', 'html', 'css', 'frontend', 'front-end'],
            'Backend': ['node', 'express', 'django', 'flask', 'python', 'java', 'backend', 'back-end', 'api', 'servidor', 'server'],
            'Blockchain': ['solidity', 'web3', 'smart contract', 'ethereum', 'blockchain', 'token', 'crypto', 'nft', 'defi'],
            'AI/ML': ['machine learning', 'ml', 'ai', 'ia', 'inteligencia artificial', 'gpt', 'llm', 'claude', 'bard', 'chatgpt'],
            'Mobile': ['android', 'ios', 'swift', 'flutter', 'react native', 'móvil', 'mobile']
        }

        # Patrones para análisis de valor comunitario
        self.community_value_patterns = {
            'shared_opportunities': ['oportunidad', 'opportunity', 'hiring', 'contratando', 'vacante', 'trabajo', 'job'],
            'helps_others': ['ayuda', 'help', 'solución', 'solution', 'respuesta', 'answer', 'explicar', 'explain'],
            'shared_learning': ['aprendí', 'learned', 'descubrí', 'discovered', 'tutorial', 'guía', 'guide'],
            'irl_events': ['meetup', 'evento', 'event', 'conferencia', 'conference', 'hackathon', 'workshop', 'taller']
        }

    def load_data(self):
        """Carga el archivo JSON de Telegram"""
        try:
            with open(self.json_path, 'r', encoding='utf-8') as file:
                self.data = json.load(file)
            print(f"✓ Archivo JSON cargado exitosamente: {self.json_path}")
            return True
        except Exception as e:
            print(f"✗ Error al cargar el archivo: {e}")
            return False

    def extract_wallet(self, text):
        """Extrae direcciones de wallet Ethereum del texto"""
        if isinstance(text, str):
            wallet_pattern = re.compile(r'0x[a-fA-F0-9]{40}')
            matches = wallet_pattern.findall(text)
            return matches[0] if matches else None
        return None

    def detect_experience(self, messages, keywords):
        """Detecta experiencia en un área específica basado en keywords"""
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for keyword in keywords:
                    if keyword in text:
                        return 'Yes'
        return None

    def detect_skills(self, messages):
        """Detecta habilidades técnicas en los mensajes"""
        skills = set()
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for tech, keywords in self.tech_keywords.items():
                    if any(keyword in text for keyword in keywords):
                        skills.add(tech)
        return ', '.join(skills) if skills else None

    def detect_primary_role(self, messages):
        """Detecta el rol primario basado en frecuencia de keywords"""
        role_counts = {role: 0 for role in self.role_keywords}
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for role, keywords in self.role_keywords.items():
                    for keyword in keywords:
                        if keyword in text:
                            role_counts[role] += 1

        if any(role_counts.values()):
            primary_role = max(role_counts, key=role_counts.get)
            return primary_role if role_counts[primary_role] > 0 else None
        return None

    def detect_project(self, messages):
        """Detecta proyectos mencionados en los mensajes"""
        project_indicators = [
            'mi proyecto', 'estoy construyendo', 'estamos desarrollando',
            'building', 'desarrollé', 'trabajando en', 'creando', 'my project',
            'we are building', 'i am building', 'working on'
        ]
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for indicator in project_indicators:
                    if indicator in text:
                        # Extraer la oración que contiene el indicador
                        start = max(0, text.find(indicator) - 50)
                        end = min(len(text), text.find(indicator) + 150)
                        return text[start:end].strip()
        return None

    def detect_communities(self, messages):
        """Detecta comunidades mencionadas en los mensajes"""
        community_indicators = ['dao', 'comunidad', 'group', 'colectivo', 'equipo de', 'community']
        communities = set()
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for indicator in community_indicators:
                    if indicator in text:
                        # Buscar palabras cercanas al indicador
                        words = text.split()
                        for i, word in enumerate(words):
                            if indicator in word and i < len(words) - 1:
                                communities.add(words[i+1])
        return ', '.join(communities) if communities else None

    def extract_email(self, messages):
        """Extrae direcciones de email de los mensajes"""
        email_pattern = re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}')
        for msg in messages:
            if isinstance(msg, str):
                matches = email_pattern.findall(msg)
                if matches:
                    return matches[0]
        return None

    def extract_social_handle(self, messages):
        """Extrae handles de redes sociales de los mensajes"""
        social_pattern = re.compile(r'@[a-zA-Z0-9_]+')
        for msg in messages:
            if isinstance(msg, str):
                matches = social_pattern.findall(msg)
                if matches:
                    # Filtrar handles que no sean menciones de Telegram
                    handles = [h for h in matches if len(h) > 2 and 'telegram' not in msg.lower()]
                    return handles[0] if handles else None
        return None

    def detect_onchain_exp(self, messages):
        """Detecta experiencia onchain basado en keywords"""
        onchain_indicators = [
            'deployed', 'desplegado', 'contrato', 'smart contract',
            'dapp', 'token', 'nft', 'web3', 'blockchain'
        ]
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                if any(indicator in text for indicator in onchain_indicators):
                    return 'Yes'
        return None

    def calculate_community_value(self, messages):
        """Calcula métricas de valor comunitario basado en patrones de mensajes"""
        metrics = {
            'shared_opportunities_count': 0,
            'helps_others_count': 0,
            'shared_learning_count': 0,
            'irl_events_count': 0,
            'reactions_received': 0,
            'mentions_count': 0,
            'conversation_starter': 'No'
        }

        # Analizar cada mensaje
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()

                # Contar patrones de valor comunitario
                for key, patterns in self.community_value_patterns.items():
                    if any(pattern in text for pattern in patterns):
                        metrics[f"{key}_count"] += 1

                # Detectar iniciadores de conversación
                conversation_starters = [
                    '¿qué opinan', 'what do you think', 'pregunta:', 'question:',
                    'alguien sabe', 'anyone knows', '¿alguien ha usado', 'has anyone used'
                ]
                if any(starter in text for starter in conversation_starters):
                    metrics['conversation_starter'] = 'Yes'

                # Contar menciones (simplificado)
                mentions = re.findall(r'@[a-zA-Z0-9_]+', text)
                metrics['mentions_count'] += len(mentions)

                # Nota: las reacciones recibidas requieren estructura adicional
                # que puede no estar disponible en todos los formatos de exportación

        return metrics

    def categorize_activity_level(self, message_count):
        """Categoriza el nivel de actividad basado en conteo de mensajes"""
        if message_count > 200:
            return "Very High"
        elif message_count > 100:
            return "High"
        elif message_count > 50:
            return "Medium"
        elif message_count > 10:
            return "Low"
        else:
            return "Very Low"

    def estimate_builder_potential(self, user_data):
        """Estima el potencial de Builder basado en múltiples factores"""
        score = 0

        # Factores técnicos
        if user_data.get('Technical Skills'):
            score += 2 * len(user_data.get('Technical Skills').split(','))

        # Experiencia
        for exp_type in ['AI Exp', 'DeFi Exp', 'SocialFi Exp']:
            if user_data.get(exp_type) == 'Yes':
                score += 3

        # Proyecto y experiencia onchain
        if user_data.get('Main Project'):
            score += 5
        if user_data.get('Built Onchain before?') == 'Yes':
            score += 5

        # Actividad
        message_count = user_data.get('Message Count', 0)
        if message_count > 200:
            score += 5
        elif message_count > 100:
            score += 3
        elif message_count > 50:
            score += 2

        # Normalizar a escala 1-10
        normalized_score = min(10, max(1, int(score / 4)))
        return normalized_score

    def process_data(self):
        """Procesa todo el archivo JSON para extraer información de usuarios"""
        if not self.data:
            print("No hay datos cargados. Ejecute load_data() primero.")
            return False

        # Inicializar recolección de datos
        self.users = {}
        self.user_messages = {}
        self.message_counts = {}

        if 'chats' in self.data and 'list' in self.data['chats']:
            print(f"Encontrados {len(self.data['chats']['list'])} chats")

            for chat in self.data['chats']['list']:
                chat_name = chat.get('name', 'Sin nombre')
                print(f"\nProcesando chat: {chat_name}")

                if 'messages' in chat:
                    print(f"  - {len(chat['messages'])} mensajes")

                    for msg in chat['messages']:
                        if 'from' in msg:
                            user_id = msg.get('from_id', '')
                            username = msg.get('from', '')  # Esto ahora irá a display_name

                            # Conteo de mensajes por usuario
                            if user_id:
                                if user_id not in self.message_counts:
                                    self.message_counts[user_id] = 0
                                self.message_counts[user_id] += 1

                            # Extraer texto del mensaje
                            text = ""
                            if 'text' in msg:
                                if isinstance(msg['text'], str):
                                    text = msg['text']
                                elif isinstance(msg['text'], list):
                                    for item in msg['text']:
                                        if isinstance(item, str):
                                            text += item + " "
                                        elif isinstance(item, dict) and 'text' in item:
                                            text += item['text'] + " "

                            # Almacenar mensaje para análisis posterior
                            if user_id:
                                if user_id not in self.user_messages:
                                    self.user_messages[user_id] = []
                                self.user_messages[user_id].append(text)

                            # Almacenar información del usuario
                            if user_id and user_id not in self.users:
                                # Formatear fecha en formato legible
                                date_str = msg.get('date', '')
                                try:
                                    date_obj = datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S')
                                    formatted_date = date_obj.strftime('%Y-%m-%d')
                                except:
                                    formatted_date = date_str

                                # Construir nombre completo
                                first_name = msg.get('from_first_name', '')
                                last_name = msg.get('from_last_name', '')
                                display_name = username  # El campo 'from' va a Display Name
                                personal_handle = f"{first_name} {last_name}".strip()  # Nombre completo a Personal Handle

                                self.users[user_id] = {
                                    'ID': user_id,  # ID original
                                    'Telegram ID': user_id,  # Nueva columna solicitada
                                    'Username': user_id.replace('user', ''),  # ID numérico sin 'user'
                                    'Personal Handle': personal_handle,  # Nombre completo
                                    'Display Name': display_name,  # Campo 'from' de Telegram
                                    'Chat': chat_name,
                                    'Last Activity': formatted_date,
                                    'Registration date': formatted_date,  # Primera actividad como aproximación
                                    'Wallet': self.extract_wallet(text),
                                    'Message Count': 1  # Inicializamos el conteo
                                }

            # Procesar mensajes para análisis profundo
            for user_id, messages in self.user_messages.items():
                if user_id in self.users:
                    # Actualizar conteo de mensajes
                    self.users[user_id]['Message Count'] = self.message_counts.get(user_id, 0)

                    # Nivel de actividad
                    self.users[user_id]['Activity Level'] = self.categorize_activity_level(
                        self.users[user_id]['Message Count']
                    )

                    # Campos técnicos
                    self.users[user_id]['Technical Skills'] = self.detect_skills(messages)
                    self.users[user_id]['Primary Role'] = self.detect_primary_role(messages)

                    # Experiencia en áreas específicas
                    self.users[user_id]['AI Exp'] = self.detect_experience(
                        messages, ['gpt', 'machine learning', 'inteligencia artificial', 'llm', 'claude', 'chatgpt', 'ai', 'ia']
                    )
                    self.users[user_id]['DeFi Exp'] = self.detect_experience(
                        messages, ['defi', 'finance', 'liquidity', 'yield', 'swap', 'lending', 'préstamo', 'finanzas']
                    )
                    self.users[user_id]['SocialFi Exp'] = self.detect_experience(
                        messages, ['social', 'community', 'token social', 'reputation', 'reputación', 'comunidad']
                    )

                    # Proyecto principal
                    self.users[user_id]['Main Project'] = self.detect_project(messages)

                    # Comunidades
                    self.users[user_id]['Communities'] = self.detect_communities(messages)

                    # Experiencia onchain
                    self.users[user_id]['Built Onchain before?'] = self.detect_onchain_exp(messages)

                    # Programas completados
                    program_keywords = ['bootcamp', 'course completed', 'curso completado', 'certificación', 'certification', 'graduated', 'graduado']
                    self.users[user_id]['Has completed a Program?'] = self.detect_experience(messages, program_keywords)

                    # Email y redes sociales
                    self.users[user_id]['Email'] = self.extract_email(messages)
                    self.users[user_id]['Social handle'] = self.extract_social_handle(messages)

                    # Plataforma social (derivada del handle)
                    social_handle = self.users[user_id]['Social handle']
                    if social_handle:
                        if 'twitter' in ' '.join(messages).lower() or 'x.com' in ' '.join(messages).lower():
                            self.users[user_id]['Social Platform'] = 'Twitter/X'
                        elif 'github' in ' '.join(messages).lower():
                            self.users[user_id]['Social Platform'] = 'GitHub'
                        else:
                            self.users[user_id]['Social Platform'] = 'Unknown'

                    # Valor comunitario
                    community_metrics = self.calculate_community_value(messages)
                    for key, value in community_metrics.items():
                        self.users[user_id][key.replace('_', ' ').title()] = value

                    # Calcular potencial de Builder
                    self.users[user_id]['Builder Potential'] = self.estimate_builder_potential(self.users[user_id])

                    # Community Value Score (combinación ponderada de métricas)
                    community_value_score = (
                        community_metrics['shared_opportunities_count'] * 3 +
                        community_metrics['helps_others_count'] * 2 +
                        community_metrics['shared_learning_count'] * 2 +
                        community_metrics['irl_events_count'] * 3 +
                        community_metrics['mentions_count']
                    )
                    self.users[user_id]['Community Value Score'] = min(10, max(1, int(community_value_score / 3)))

                    # Next steps (campo a llenar manualmente)
                    self.users[user_id]['Next steps'] = 'Contact for more information'

                    # Etapa H2F (placeholder para clasificación manual posterior)
                    self.users[user_id]['H2F Stage'] = 'Initial Contact'

            return True
        else:
            print("Estructura de chats no encontrada en el JSON")
            return False

    def export_to_csv(self, output_path='builders_dashboard_advanced.csv'):
        """Exporta los datos procesados a un archivo CSV"""
        if not self.users:
            print("No hay datos de usuarios para exportar")
            return False

        # Crear DataFrame con los usuarios
        user_list = list(self.users.values())
        if user_list:
            df = pd.DataFrame(user_list)

            # Reorganizar columnas para que coincidan con el Builder Dashboard
            columns = [
                'ID', 'Telegram ID', 'Wallet', 'Username', 'Personal Handle', 'Display Name',
                'Primary Role', 'H2F Stage', 'Technical Skills', 'AI Exp', 'SocialFi Exp', 'DeFi Exp',
                'Main Project', 'Communities', 'Built Onchain before?', 'Message Count', 'Activity Level',
                'Builder Potential', 'Community Value Score', 'Shared Opportunities Count',
                'Helps Others Count', 'Shared Learning Count', 'Irl Events Count',
                'Mentions Count', 'Conversation Starter', 'Has completed a Program?',
                'Email', 'Social handle', 'Social Platform', 'Registration date', 'Last Activity', 'Next steps'
            ]

            # Asegurar que todas las columnas existan
            for col in columns:
                if col not in df.columns:
                    df[col] = None

            # Reordenar columnas
            existing_columns = [col for col in columns if col in df.columns]
            df = df[existing_columns]

            print(f"\nExportando {len(df)} usuarios únicos con información detallada")

            # Guardar a CSV con codificación UTF-8
            df.to_csv(output_path, index=False, encoding='utf-8')
            print(f"\n¡Datos procesados! Archivo guardado como: {output_path}")

            return True
        else:
            print("No se encontraron usuarios para exportar")
            return False

# Función principal para ejecutar todo el proceso
def process_telegram_data(json_path, output_path='builders_dashboard_advanced.csv'):
    """
    Procesa un archivo JSON de Telegram y extrae datos de usuarios a un CSV

    Args:
        json_path: Ruta al archivo JSON de Telegram
        output_path: Ruta donde guardar el CSV de salida

    Returns:
        bool: True si el proceso fue exitoso, False si hubo errores
    """
    processor = TelegramDataProcessor(json_path)

    if not processor.load_data():
        return False

    if not processor.process_data():
        return False

    if not processor.export_to_csv(output_path):
        return False

    print(f"\n✅ Procesamiento completo. Resultados guardados en {output_path}")
    return True

# Ejemplo de uso
if __name__ == "__main__":
    # Ruta al archivo JSON (adaptar según sea necesario)
    json_path = 'result.json'

    # Ruta para el archivo CSV de salida
    output_path = 'builders_dashboard_advanced.csv'

    # Procesar los datos
    success = process_telegram_data(json_path, output_path)

    if success:
        print("\nPara descargar el archivo en Google Colab, ejecuta:")
        print("from google.colab import files")
        print(f"files.download('{output_path}')")
    else:
        print("\n⚠️ Ocurrieron errores durante el procesamiento")
